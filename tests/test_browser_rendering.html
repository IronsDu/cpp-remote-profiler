<!DOCTYPE html>
<html>
<head>
    <title>ç«ç„°å›¾æ¸²æŸ“æµ‹è¯•</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        body { font-family: monospace; padding: 20px; background: #f0f0f0; }
        .test { background: white; padding: 15px; margin: 10px 0; border-radius: 5px; }
        .pass { border-left: 5px solid #4CAF50; }
        .fail { border-left: 5px solid #f44336; }
        .info { border-left: 5px solid #2196F3; }
        pre { background: #f5f5f5; padding: 10px; overflow-x: auto; }
        button { padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; margin: 5px; }
        button:hover { background: #45a049; }
        #results { max-width: 1200px; margin: 0 auto; }
        canvas { border: 1px solid #ccc; background: white; }
    </style>
</head>
<body>
    <h1>ğŸ”¥ ç«ç„°å›¾æ¸²æŸ“è‡ªåŠ¨åŒ–æµ‹è¯•</h1>
    <div id="results"></div>

    <script>
        const results = [];

        function log(test, status, message, details = '') {
            results.push({ test, status, message, details });
            const className = status === 'PASS' ? 'pass' : (status === 'FAIL' ? 'fail' : 'info');
            const icon = status === 'PASS' ? 'âœ…' : (status === 'FAIL' ? 'âŒ' : 'â„¹ï¸');
            const html = `
                <div class="test ${className}">
                    <strong>${icon} ${test}</strong>: ${message}
                    ${details ? `<pre>${details}</pre>` : ''}
                </div>
            `;
            $('#results').append(html);
        }

        async function testAPI(endpoint, testName) {
            try {
                const response = await fetch(endpoint);
                const data = await response.json();
                log(testName, 'PASS', 'APIå“åº”æˆåŠŸ', JSON.stringify(data, null, 2));
                return data;
            } catch (error) {
                log(testName, 'FAIL', 'APIè¯·æ±‚å¤±è´¥: ' + error.message);
                return null;
            }
        }

        async function testFlameGraphRendering(profileType) {
            log(`ç«ç„°å›¾æ¸²æŸ“æµ‹è¯• (${profileType})`, 'INFO', 'å¼€å§‹æµ‹è¯•...');

            // 1. è·å–ç«ç„°å›¾æ•°æ®
            const data = await testAPI(`/api/${profileType}/flamegraph`, `è·å–${profileType}ç«ç„°å›¾æ•°æ®`);
            if (!data) return false;

            // 2. éªŒè¯æ•°æ®ç»“æ„
            if (!data.name || !data.children || !Array.isArray(data.children)) {
                log(`æ•°æ®ç»“æ„éªŒè¯ (${profileType})`, 'FAIL', 'ç¼ºå°‘å¿…éœ€å­—æ®µ');
                return false;
            }
            log(`æ•°æ®ç»“æ„éªŒè¯ (${profileType})`, 'PASS', 'åŒ…å«nameå’Œchildrenå­—æ®µ');

            // 3. éªŒè¯totalå€¼
            if (data.total && data.total > 0) {
                log(`Totalå€¼éªŒè¯ (${profileType})`, 'PASS', `total = ${data.total}`);
            } else {
                log(`Totalå€¼éªŒè¯ (${profileType})`, 'INFO', 'totalä¸º0æˆ–æœªå®šä¹‰ï¼ˆæ¼”ç¤ºæ•°æ®ï¼‰');
            }

            // 4. éªŒè¯childrenæ•°ç»„
            if (data.children.length > 0) {
                log(`Childrenæ•°ç»„éªŒè¯ (${profileType})`, 'PASS', `åŒ…å« ${data.children.length} ä¸ªå­èŠ‚ç‚¹`);
            } else {
                log(`Childrenæ•°ç»„éªŒè¯ (${profileType})`, 'FAIL', 'childrenæ•°ç»„ä¸ºç©º');
                return false;
            }

            // 5. éªŒè¯æ¯ä¸ªå­èŠ‚ç‚¹
            let validChildren = 0;
            data.children.forEach((child, index) => {
                if (child.name && child.value !== undefined) {
                    validChildren++;
                } else {
                    log(`å­èŠ‚ç‚¹${index}éªŒè¯ (${profileType})`, 'FAIL', 'ç¼ºå°‘nameæˆ–valueå­—æ®µ');
                }
            });

            if (validChildren === data.children.length) {
                log(`æ‰€æœ‰å­èŠ‚ç‚¹éªŒè¯ (${profileType})`, 'PASS', `${validChildren} ä¸ªå­èŠ‚ç‚¹éƒ½æœ‰æ•ˆ`);
            }

            // 6. éªŒè¯Canvasæ¸²æŸ“ï¼ˆåˆ›å»ºä¸´æ—¶canvasï¼‰
            return await testCanvasRendering(data, profileType);
        }

        async function testCanvasRendering(data, profileType) {
            return new Promise((resolve) => {
                // åˆ›å»ºä¸´æ—¶canvas
                const canvas = document.createElement('canvas');
                canvas.width = 800;
                canvas.height = 400;
                document.body.appendChild(canvas);

                const ctx = canvas.getContext('2d');

                try {
                    // è®¡ç®—æ€»å€¼
                    const total = data.total || data.children.reduce((sum, child) => sum + (child.value || 0), 0);

                    // æ¸²æŸ“æµ‹è¯•
                    let renderedCount = 0;
                    const barHeight = 30;
                    const margin = 20;
                    let x = margin;
                    const availableWidth = 800 - 2 * margin;

                    // æ¸²æŸ“ç¬¬ä¸€å±‚
                    for (const child of data.children) {
                        if (!child.value || child.value <= 0) continue;

                        const childWidth = (child.value / total) * availableWidth;
                        if (childWidth < 1) continue;

                        // ç»˜åˆ¶æµ‹è¯•çŸ©å½¢
                        ctx.fillStyle = '#FF6B6B';
                        ctx.fillRect(x, margin + 60, childWidth, barHeight);
                        renderedCount++;
                        x += childWidth;
                    }

                    if (renderedCount > 0) {
                        log(`Canvasæ¸²æŸ“æµ‹è¯• (${profileType})`, 'PASS', `æˆåŠŸæ¸²æŸ“ ${renderedCount} ä¸ªå‡½æ•°å—`);
                        document.body.removeChild(canvas);
                        resolve(true);
                    } else {
                        log(`Canvasæ¸²æŸ“æµ‹è¯• (${profileType})`, 'FAIL', 'æ²¡æœ‰æ¸²æŸ“ä»»ä½•å†…å®¹');
                        document.body.removeChild(canvas);
                        resolve(false);
                    }
                } catch (error) {
                    log(`Canvasæ¸²æŸ“æµ‹è¯• (${profileType})`, 'FAIL', 'æ¸²æŸ“é”™è¯¯: ' + error.message);
                    document.body.removeChild(canvas);
                    resolve(false);
                }
            });
        }

        async function testColorGeneration() {
            log('é¢œè‰²ç”Ÿæˆæµ‹è¯•', 'INFO', 'æµ‹è¯•ä¸åŒå‡½æ•°åçš„é¢œè‰²ç”Ÿæˆ...');

            const testNames = [
                'std::sort',
                'fib',
                'operator new',
                'cpuIntensiveTask',
                'memoryIntensiveTask'
            ];

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const colors = [];

            // æµ‹è¯•å“ˆå¸Œä¸€è‡´æ€§
            for (const name of testNames) {
                let hash = 0;
                for (let i = 0; i < name.length; i++) {
                    hash = name.charCodeAt(i) + ((hash << 5) - hash);
                }

                const hue = 30 + (hash % 30);
                const saturation = 70 + (Math.random() * 30);
                const lightness = 60 - (Math.random() * 20);
                const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;

                colors.push({ name, color, hash });
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰é‡å¤çš„å“ˆå¸Œ
            const uniqueHashes = new Set(colors.map(c => c.hash));
            if (uniqueHashes.size === colors.length) {
                log('å“ˆå¸Œå”¯ä¸€æ€§æµ‹è¯•', 'PASS', 'æ‰€æœ‰å‡½æ•°åéƒ½æœ‰å”¯ä¸€çš„å“ˆå¸Œå€¼');
            } else {
                log('å“ˆå¸Œå”¯ä¸€æ€§æµ‹è¯•', 'FAIL', 'å­˜åœ¨é‡å¤çš„å“ˆå¸Œå€¼');
            }

            // æ£€æŸ¥é¢œè‰²èŒƒå›´
            const allValid = colors.every(c => c.color.includes('hsl'));
            if (allValid) {
                log('é¢œè‰²æ ¼å¼æµ‹è¯•', 'PASS', 'æ‰€æœ‰é¢œè‰²éƒ½æ˜¯æœ‰æ•ˆçš„HSLæ ¼å¼');
                log('é¢œè‰²ç¤ºä¾‹', 'INFO', 'ç”Ÿæˆçš„é¢œè‰²', colors.map(c => `${c.name}: ${c.color}`).join('\n'));
            }

            return allValid;
        }

        async function testXMLParsing() {
            log('XMLè§£ææµ‹è¯•', 'INFO', 'æµ‹è¯•SVGæ˜¯å¦å¯ä»¥è¢«æ­£ç¡®è§£æ...');

            try {
                const response = await fetch('/api/cpu/svg');
                const svgText = await response.text();

                // æ£€æŸ¥XMLå£°æ˜
                if (svgText.includes('<?xml version="1.0"')) {
                    log('XMLå£°æ˜', 'PASS', 'åŒ…å«XMLå£°æ˜');
                } else {
                    log('XMLå£°æ˜', 'FAIL', 'ç¼ºå°‘XMLå£°æ˜');
                }

                // æ£€æŸ¥SVGæ ‡ç­¾
                if (svgText.includes('<svg') && svgText.includes('</svg>')) {
                    log('SVGæ ‡ç­¾', 'PASS', 'åŒ…å«å®Œæ•´çš„SVGæ ‡ç­¾');
                } else {
                    log('SVGæ ‡ç­¾', 'FAIL', 'ç¼ºå°‘SVGæ ‡ç­¾');
                }

                // æ£€æŸ¥XMLç‰¹æ®Šå­—ç¬¦è½¬ä¹‰
                const hasEscapedChars = svgText.includes('&lt;') || svgText.includes('&gt;') || svgText.includes('&amp;');
                if (hasEscapedChars) {
                    log('XMLè½¬ä¹‰', 'PASS', 'å‘ç°è½¬ä¹‰å­—ç¬¦');
                } else {
                    log('XMLè½¬ä¹‰', 'INFO', 'æœªå‘ç°è½¬ä¹‰å­—ç¬¦ï¼ˆå¯èƒ½æ²¡æœ‰ç‰¹æ®Šå­—ç¬¦éœ€è¦è½¬ä¹‰ï¼‰');
                }

                // å°è¯•è§£æä¸ºDOM
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(svgText, 'image/svg+xml');
                const parseError = xmlDoc.querySelector('parsererror');

                if (parseError) {
                    log('DOMè§£æ', 'FAIL', 'XMLè§£æå¤±è´¥: ' + parseError.textContent);
                    return false;
                } else {
                    log('DOMè§£æ', 'PASS', 'SVGå¯ä»¥æˆåŠŸè§£æä¸ºDOM');
                    return true;
                }
            } catch (error) {
                log('XMLè§£ææµ‹è¯•', 'FAIL', 'é”™è¯¯: ' + error.message);
                return false;
            }
        }

        async function runAllTests() {
            $('#results').empty();
            results.length = 0;

            log('æµ‹è¯•å¥—ä»¶', 'INFO', 'å¼€å§‹è‡ªåŠ¨åŒ–æµ‹è¯•...', `æµ‹è¯•æ—¶é—´: ${new Date().toLocaleString()}`);

            // 1. æµ‹è¯•APIçŠ¶æ€
            await testAPI('/api/status', 'çŠ¶æ€APIæµ‹è¯•');

            // 2. æµ‹è¯•CPUç«ç„°å›¾
            await testFlameGraphRendering('cpu');

            // 3. æµ‹è¯•Heapç«ç„°å›¾
            await testFlameGraphRendering('heap');

            // 4. æµ‹è¯•é¢œè‰²ç”Ÿæˆ
            await testColorGeneration();

            // 5. æµ‹è¯•XMLè§£æ
            await testXMLParsing();

            // ç”Ÿæˆæ€»ç»“
            const passed = results.filter(r => r.status === 'PASS').length;
            const failed = results.filter(r => r.status === 'FAIL').length;
            const info = results.filter(r => r.status === 'INFO').length;
            const total = results.length;

            const summary = `
                <div class="test ${failed === 0 ? 'pass' : 'fail'}" style="margin-top: 30px; padding: 20px;">
                    <h2>ğŸ“Š æµ‹è¯•æ€»ç»“</h2>
                    <p><strong>æ€»æµ‹è¯•æ•°:</strong> ${total}</p>
                    <p><strong>âœ… é€šè¿‡:</strong> ${passed}</p>
                    <p><strong>âŒ å¤±è´¥:</strong> ${failed}</p>
                    <p><strong>â„¹ï¸  ä¿¡æ¯:</strong> ${info}</p>
                    <p><strong>æˆåŠŸç‡:</strong> ${((passed / (total - info)) * 100).toFixed(1)}%</p>
                    ${failed === 0 ? '<p style="color: green; font-weight: bold;">ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼</p>' : '<p style="color: red; font-weight: bold;">âš ï¸ å­˜åœ¨å¤±è´¥çš„æµ‹è¯•</p>'}
                </div>
            `;

            $('#results').append(summary);
        }

        // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨è¿è¡Œæµ‹è¯•
        $(document).ready(function() {
            setTimeout(runAllTests, 500);
        });
    </script>
</body>
</html>
