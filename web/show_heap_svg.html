<!DOCTYPE html>
<html>
<head>
    <title>Heap Flame Graph Viewer</title>
    <style>
        body { margin: 0; padding: 20px; font-family: Arial, sans-serif; background: #f5f5f5; }
        h1 { color: #333; margin-bottom: 10px; }
        .info { background: #fff3e0; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .info ul { margin: 10px 0; padding-left: 20px; }
        .info li { margin: 5px 0; }
        .toolbar { margin-bottom: 20px; }
        button { padding: 10px 20px; margin-right: 10px; cursor: pointer; font-size: 14px; }
        button:hover { background: #f0f0f0; }
        #svg-container {
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 20px;
            overflow: auto;
            max-width: 100%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-height: 600px;
            max-height: 80vh;
        }
        svg {
            display: block;
            margin: 0 auto;
            min-width: 100%;
            min-height: 100%;
        }
    </style>
</head>
<body>
    <h1>ğŸ”¥ Heap å†…å­˜ç«ç„°å›¾</h1>
    <div class="info">
        <strong>ğŸ’¡ æŸ¥çœ‹æç¤ºï¼š</strong>
        <ul>
            <li><strong>æ»šåŠ¨ï¼š</strong> å›¾è¡¨å¯èƒ½å¾ˆå¤§ï¼Œè¯·æ»šåŠ¨æŸ¥çœ‹æ‰€æœ‰å‡½æ•°</li>
            <li><strong>ç¼©æ”¾ï¼š</strong> ä½¿ç”¨é¼ æ ‡æ»šè½®å¯ä»¥ç¼©æ”¾è§†å›¾</li>
            <li><strong>æ‹–æ‹½ï¼š</strong> æŒ‰ä½é¼ æ ‡å·¦é”®å¯ä»¥æ‹–åŠ¨å›¾è¡¨</li>
            <li><strong>æœç´¢ï¼š</strong> ä½¿ç”¨ Ctrl+F æœç´¢ç‰¹å®šå‡½æ•°ï¼ˆå¦‚ cpuIntensiveTaskã€FibonacciCalculatorï¼‰</li>
            <li><strong>ç‚¹å‡»ï¼š</strong> ç‚¹å‡»èŠ‚ç‚¹å¯ä»¥é«˜äº®æ˜¾ç¤ºç›¸å…³è°ƒç”¨</li>
        </ul>
    </div>
    <div class="toolbar">
        <button onclick="loadSVG()">ğŸ”„ é‡æ–°åŠ è½½</button>
        <button onclick="zoomIn()">ğŸ”+ æ”¾å¤§</button>
        <button onclick="zoomOut()">ğŸ”- ç¼©å°</button>
        <button onclick="resetZoom()">1:1 åŸå§‹å¤§å°</button>
        <button onclick="fitToWidth()">â†”ï¸ é€‚åº”å®½åº¦</button>
        <button onclick="window.print()">ğŸ–¨ï¸ æ‰“å°</button>
        <button onclick="downloadSVG()">â¬‡ï¸ ä¸‹è½½ SVG</button>
    </div>
    <div id="svg-container">åŠ è½½ä¸­...</div>

    <script>
        let currentZoom = 1.0;
        let svgElement = null;
        let viewportElement = null;

        function loadSVG() {
            document.getElementById('svg-container').innerHTML = 'æ­£åœ¨åŠ è½½Heapç«ç„°å›¾...';

            // Heapåˆ†æä¸éœ€è¦durationå‚æ•°ï¼Œç›´æ¥è°ƒç”¨æ¥å£
            fetch('/api/heap/analyze')
                .then(response => {
                    const contentType = response.headers.get('Content-Type');
                    if (contentType && contentType.includes('json')) {
                        return response.json().then(data => {
                            throw new Error(data.error || 'æœªçŸ¥é”™è¯¯');
                        });
                    }
                    return response.text();
                })
                .then(svgText => {
                    const container = document.getElementById('svg-container');
                    container.innerHTML = svgText;

                    // è°ƒæ•´ SVG çš„æ˜¾ç¤ºï¼Œç¡®ä¿å®Œæ•´æ¸²æŸ“
                    setTimeout(() => {
                        const svg = container.querySelector('svg');
                        svgElement = svg;
                        if (svg) {
                            // ç§»é™¤å›ºå®šçš„å®½é«˜ï¼Œè®©SVGè‡ªé€‚åº”
                            svg.removeAttribute('width');
                            svg.removeAttribute('height');

                            // è®¾ç½®ä¸€ä¸ªåˆç†çš„æœ€å°å°ºå¯¸
                            svg.style.minWidth = '100%';
                            svg.style.minHeight = '600px';

                            // æŸ¥æ‰¾å¹¶è°ƒæ•´ viewport transform
                            const viewport = svg.querySelector('#viewport');
                            viewportElement = viewport;
                            if (viewport) {
                                // è·å–å½“å‰çš„ transform
                                const transform = viewport.getAttribute('transform');
                                console.log('Original transform:', transform);

                                // ä¸ä¿®æ”¹ transformï¼Œä¿æŒ pprof çš„åŸå§‹å¸ƒå±€
                                // ä½†æ·»åŠ ä¸€äº›æ ·å¼è®©æ˜¾ç¤ºæ›´å¥½
                                viewport.style.transformBox = 'fill-box';
                                viewport.style.transformOrigin = 'top left';
                            }

                            // è‡ªåŠ¨æ»šåŠ¨åˆ°åŒ…å«æˆ‘ä»¬å‡½æ•°çš„åŒºåŸŸ
                            const titles = svg.querySelectorAll('title');
                            let found = false;
                            for (let title of titles) {
                                const text = title.textContent;
                                if (text.includes('cpuIntensiveTask') ||
                                    text.includes('FibonacciCalculator') ||
                                    text.includes('memoryIntensiveTask') ||
                                    text.includes('DataProcessor') ||
                                    text.includes('MatrixOperations')) {
                                    const node = title.closest('g');
                                    if (node && !found) {
                                        node.scrollIntoView({behavior: 'smooth', block: 'center'});
                                        found = true;

                                        // é«˜äº®æ˜¾ç¤ºæ‰¾åˆ°çš„èŠ‚ç‚¹
                                        node.style.outline = '3px solid red';
                                        node.style.outlineOffset = '2px';
                                    }
                                }
                            }

                            if (found) {
                                console.log('Found and scrolled to target function');
                            } else {
                                console.log('Target function not found, showing all nodes');
                                // å¦‚æœæ²¡æ‰¾åˆ°ç›®æ ‡å‡½æ•°ï¼Œæ»šåŠ¨åˆ°ä¸­é—´
                                const viewport = svg.querySelector('#viewport');
                                if (viewport) {
                                    viewport.scrollIntoView({behavior: 'smooth', block: 'center'});
                                }
                            }
                        }
                    }, 300);
                })
                .catch(error => {
                    document.getElementById('svg-container').innerHTML =
                        `<div style="color: red; padding: 20px;">âŒ åŠ è½½å¤±è´¥: ${error.message}</div>`;
                });
        }

        function zoomIn() {
            if (!svgElement) return;
            currentZoom *= 1.2;
            applyZoom();
        }

        function zoomOut() {
            if (!svgElement) return;
            currentZoom /= 1.2;
            applyZoom();
        }

        function resetZoom() {
            if (!svgElement) return;
            currentZoom = 1.0;
            applyZoom();
        }

        function fitToWidth() {
            if (!svgElement || !viewportElement) return;
            const container = document.getElementById('svg-container');
            const containerWidth = container.clientWidth - 40; // padding

            // è·å– SVG çš„å®é™…å®½åº¦
            const bbox = viewportElement.getBBox();
            const svgWidth = bbox.width;

            currentZoom = containerWidth / svgWidth;
            applyZoom();
        }

        function applyZoom() {
            if (!viewportElement) return;

            // è·å–åŸå§‹çš„ transform
            const originalTransform = viewportElement.getAttribute('transform') || '';

            // è§£æåŸå§‹çš„ scale
            const scaleMatch = originalTransform.match(/scale\(([^)]+)\)/);
            const baseScale = scaleMatch ? parseFloat(scaleMatch[1]) : 1.0;

            // è§£æåŸå§‹çš„ translate
            const translateMatch = originalTransform.match(/translate\(([^)]+)\)/);
            const baseTranslate = translateMatch ? translateMatch[1] : '0,0';

            // åº”ç”¨æ–°çš„ç¼©æ”¾
            const newScale = baseScale * currentZoom;
            viewportElement.setAttribute('transform',
                `scale(${newScale},${newScale}) translate(${baseTranslate})`);

            console.log(`Applied zoom: ${currentZoom}x (${newScale})`);
        }

        function downloadSVG() {
            const svg = document.querySelector('svg');
            if (!svg) {
                alert('æ²¡æœ‰æ‰¾åˆ° SVG å›¾è¡¨');
                return;
            }
            const serializer = new XMLSerializer();
            const svgStr = serializer.serializeToString(svg);
            const blob = new Blob([svgStr], {type: 'image/svg+xml'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            // ä½¿ç”¨æ—¶é—´æˆ³ç”Ÿæˆæ–‡ä»¶å
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            a.download = `heap_flamegraph_${timestamp}.svg`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨åŠ è½½ SVG
        window.addEventListener('load', loadSVG);
    </script>
</body>
</html>
