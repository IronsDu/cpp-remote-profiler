<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç«ç„°å›¾æŸ¥çœ‹å™¨ - Flame Graph Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }
        .header p {
            font-size: 16px;
            opacity: 0.9;
        }
        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        .controls select, .controls input {
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }
        .controls button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        .controls button:hover {
            background: #5568d3;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .controls button:active {
            transform: translateY(0);
        }
        .controls button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .search-box {
            flex: 1;
            min-width: 200px;
        }
        .stats {
            display: flex;
            gap: 20px;
            padding: 15px 20px;
            background: #fff3cd;
            border-bottom: 1px solid #ffc107;
            font-size: 14px;
        }
        .stats strong {
            color: #856404;
        }
        .progress {
            display: flex;
            gap: 20px;
            padding: 15px 20px;
            background: #e7f3ff;
            border-bottom: 1px solid #b3d9ff;
            font-size: 14px;
            align-items: center;
        }
        .progress-bar {
            flex: 1;
            height: 8px;
            background: #ddd;
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s;
        }
        .canvas-container {
            position: relative;
            padding: 20px;
            background: #f8f9fa;
        }
        #flameCanvas {
            width: 100%;
            height: 500px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: crosshair;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 13px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            display: none;
        }
        .tooltip .name {
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffd700;
        }
        .tooltip .value {
            color: #4fc3f7;
        }
        .tooltip .percentage {
            color: #81c784;
        }
        .tooltip .stack {
            margin-top: 5px;
            padding-top: 5px;
            border-top: 1px solid rgba(255,255,255,0.2);
            font-size: 11px;
            color: #aaa;
        }
        .info-panel {
            padding: 20px;
            background: #e7f3ff;
            border-top: 1px solid #b3d9ff;
        }
        .info-panel h3 {
            color: #004085;
            margin-bottom: 10px;
        }
        .info-panel ul {
            margin-left: 20px;
            color: #004085;
        }
        .info-panel li {
            margin: 5px 0;
        }
        .back-link {
            display: inline-block;
            margin-top: 10px;
            color: #667eea;
            text-decoration: none;
            font-weight: bold;
        }
        .back-link:hover {
            text-decoration: underline;
        }
        .legend {
            display: flex;
            gap: 15px;
            padding: 10px 20px;
            background: white;
            border-bottom: 1px solid #dee2e6;
            font-size: 13px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-color {
            width: 30px;
            height: 15px;
            border-radius: 3px;
        }
        .loading {
            text-align: center;
            padding: 60px;
            font-size: 18px;
            color: #666;
        }
        .loading::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
        .zoom-info {
            padding: 10px 20px;
            background: #fff;
            border-bottom: 1px solid #dee2e6;
            font-size: 13px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”¥ äº¤äº’å¼ç«ç„°å›¾æŸ¥çœ‹å™¨</h1>
            <p>Interactive Flame Graph Viewer - ç”¨äºC++æ€§èƒ½åˆ†æå¯è§†åŒ–</p>
            <a href="/" class="back-link">â† è¿”å›ä¸»é¡µ</a>
        </div>

        <div class="controls">
            <select id="profileType">
                <option value="cpu">CPU Profile</option>
                <option value="heap">Heap Profile</option>
            </select>
            <input type="text" id="searchInput" class="search-box" placeholder="ğŸ” æœç´¢å‡½æ•°å...">
            <button onclick="searchFunction()">æœç´¢</button>
            <button onclick="resetZoom()">é‡ç½®ç¼©æ”¾</button>
            <button onclick="refreshData()" id="refreshBtn">åˆ·æ–°æ•°æ®</button>
            <button onclick="downloadSVG()">ä¸‹è½½SVG</button>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: rgb(147, 112, 219);"></div>
                <span>å†…è”å‡½æ•°</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgb(255, 200, 150);"></div>
                <span>ä½çƒ­åº¦</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgb(255, 100, 50);"></div>
                <span>ä¸­çƒ­åº¦</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgb(255, 0, 0);"></div>
                <span>é«˜çƒ­åº¦</span>
            </div>
        </div>

        <div class="progress" id="progress" style="display: none;">
            <span id="progressText">å‡†å¤‡ä¸­...</span>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
        </div>

        <div class="stats" id="stats" style="display: none;">
            <span><strong>æ€»é‡‡æ ·:</strong> <span id="totalSamples">-</span></span>
            <span><strong>å‡½æ•°æ•°é‡:</strong> <span id="functionCount">-</span></span>
            <span><strong>æœ€å¤§è€—æ—¶:</strong> <span id="maxValue">-</span></span>
        </div>

        <div class="zoom-info" id="zoomInfo" style="display: none;">
            <span id="zoomText"></span>
        </div>

        <div class="canvas-container">
            <div id="loading" class="loading">åŠ è½½ç«ç„°å›¾æ•°æ®</div>
            <canvas id="flameCanvas"></canvas>
            <div id="tooltip" class="tooltip"></div>
        </div>

        <div class="info-panel">
            <h3>ğŸ’¡ ä½¿ç”¨è¯´æ˜</h3>
            <ul>
                <li><strong>é¼ æ ‡æ‚¬åœ:</strong> æŸ¥çœ‹å‡½æ•°è¯¦ç»†ä¿¡æ¯ï¼ˆåç§°ã€è€—æ—¶ã€ç™¾åˆ†æ¯”ã€å†…è”å‡½æ•°ï¼‰</li>
                <li><strong>ç‚¹å‡»:</strong> ç‚¹å‡»å‡½æ•°å—å¯èšç„¦åˆ°è¯¥å‡½æ•°ï¼Œå†æ¬¡ç‚¹å‡»é‡ç½®</li>
                <li><strong>æ»šè½®:</strong> ä»¥é¼ æ ‡ä½ç½®ä¸ºä¸­å¿ƒè¿›è¡Œç¼©æ”¾</li>
                <li><strong>æœç´¢:</strong> é«˜äº®æ˜¾ç¤ºåŒ¹é…çš„å‡½æ•°ï¼ˆè¾“å…¥å‡½æ•°åæˆ–æ­£åˆ™è¡¨è¾¾å¼ï¼‰</li>
                <li><strong>å†…è”å‡½æ•°:</strong> ç´«è‰²æ˜¾ç¤ºï¼Œä½¿ç”¨ "--" è¿æ¥è°ƒç”¨é“¾</li>
            </ul>
        </div>
    </div>

    <script>
        // ç«ç„°å›¾æ•°æ®
        let flameData = null;
        let canvas, ctx;
        let tooltip;

        // ç¼©æ”¾å’Œè§†å›¾çŠ¶æ€
        let zoomState = {
            scale: 1.0,
            offsetX: 0,
            focusedNode: null
        };

        // æœç´¢çŠ¶æ€
        let searchResults = [];
        let currentSearchIndex = 0;

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('flameCanvas');
            ctx = canvas.getContext('2d');
            tooltip = document.getElementById('tooltip');

            setupCanvas();
            setupEventListeners();

            // ä»URLå‚æ•°è·å–profileç±»å‹
            const urlParams = new URLSearchParams(window.location.search);
            const profileType = urlParams.get('type');
            if (profileType === 'cpu' || profileType === 'heap') {
                document.getElementById('profileType').value = profileType;
            }

            // ç›´æ¥åŠ è½½æ•°æ®
            refreshData();
        });

        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;

            ctx.scale(dpr, dpr);
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
        }

        function setupEventListeners() {
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('click', handleClick);
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            canvas.addEventListener('mouseleave', () => {
                tooltip.style.display = 'none';
            });

            document.getElementById('searchInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    searchFunction();
                }
            });

            window.addEventListener('resize', () => {
                setupCanvas();
                if (flameData) {
                    renderFlameGraph();
                }
            });
        }

        function showProgress(show, text = '', percent = 0) {
            const progress = document.getElementById('progress');
            const progressText = document.getElementById('progressText');
            const progressFill = document.getElementById('progressFill');
            const loading = document.getElementById('loading');
            const refreshBtn = document.getElementById('refreshBtn');

            if (show) {
                progress.style.display = 'flex';
                progressText.textContent = text;
                progressFill.style.width = percent + '%';
                loading.style.display = 'none';
                refreshBtn.disabled = true;
            } else {
                progress.style.display = 'none';
                refreshBtn.disabled = false;
            }
        }

        function showError(message) {
            const loading = document.getElementById('loading');
            loading.textContent = `âŒ é”™è¯¯: ${message}`;
        }

        async function refreshData() {
            const profileType = document.getElementById('profileType').value;
            const stats = document.getElementById('stats');

            try {
                showProgress(true, 'ä¸‹è½½ profile æ–‡ä»¶...', 10);

                if (profileType === 'cpu') {
                    // CPU profile: ä¸‹è½½äºŒè¿›åˆ¶profæ–‡ä»¶å¹¶è§£æ
                    await processCPUProfileText();
                } else {
                    // Heap profile: ä½¿ç”¨ profile æ¥å£è·å–åŸå§‹æ–‡ä»¶
                    const response = await fetch('/api/heap/profile');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    showProgress(true, 'è§£æ heap profile...', 30);
                    const text = await response.text();
                    await processHeapProfile(text);
                }

                stats.style.display = 'flex';
                showProgress(false);
            } catch (error) {
                showProgress(false);
                showError(error.message);
                console.error('Error loading profile:', error);
            }
        }

        async function processCPUProfileText() {
            showProgress(true, 'ä¸‹è½½ CPU profile æ–‡ä»¶...', 20);

            try {
                // ä¸‹è½½äºŒè¿›åˆ¶profæ–‡ä»¶
                const response = await fetch('/api/cpu/profile');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                showProgress(true, 'è§£æ CPU profile äºŒè¿›åˆ¶æ•°æ®...', 40);

                const buffer = await response.arrayBuffer();

                // è§£ægperftoolsäºŒè¿›åˆ¶æ ¼å¼
                const { samples, addresses } = parseGperftoolsProfile(buffer);

                if (samples.length === 0) {
                    throw new Error('æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„é‡‡æ ·æ•°æ®');
                }

                console.log(`è§£æåˆ° ${samples.length} ä¸ªé‡‡æ ·ï¼Œ${addresses.size} ä¸ªå”¯ä¸€åœ°å€`);

                showProgress(true, `æ‰¹é‡ç¬¦å·åŒ– ${addresses.size} ä¸ªåœ°å€...`, 60);

                // æ‰¹é‡ç¬¦å·åŒ–
                const symbolMap = await batchSymbolize(Array.from(addresses));

                showProgress(true, 'æ„å»ºç«ç„°å›¾æ•°æ®...', 80);

                // æ„å»ºç«ç„°å›¾æ•°æ®
                flameData = buildFlameGraph(samples, symbolMap);

                resetZoom();
                renderFlameGraph();
                updateStats(flameData);

                showProgress(true, 'å®Œæˆ!', 100);
                setTimeout(() => showProgress(false), 500);
            } catch (e) {
                console.error('Error processing CPU profile:', e);
                throw new Error('è§£æ CPU profile å¤±è´¥: ' + e.message);
            }
        }

        async function processHeapProfile(text) {
            showProgress(true, 'è§£æ heap profile...', 40);

            try {
                // è§£æ heap profile æ–‡æœ¬æ ¼å¼
                const lines = text.split('\n');
                const samples = [];
                const addresses = new Set();

                for (const line of lines) {
                    if (!line || line.startsWith('#') || line.startsWith('heap profile:')) {
                        continue;
                    }

                    // heap profile æ ¼å¼: "count: bytes [self: bytes] @ addr1 addr2 addr3 ..."
                    // ç®€åŒ–åŒ¹é…
                    const match = line.match(/(\d+):\s+(\d+)\s+\[\d+:\s+\d+\]\s+@(.+)/);
                    if (match) {
                        const count = parseInt(match[1]);
                        const bytes = parseInt(match[2]);
                        const addrStr = match[3].trim();

                        if (addrStr) {
                            const stack = addrStr.split(/\s+/).reverse();
                            for (const addr of stack) {
                                addresses.add(addr);
                            }
                            samples.push({
                                stack: stack,
                                value: bytes
                            });
                        }
                    }
                }

                showProgress(true, `æ‰¹é‡ç¬¦å·åŒ– ${addresses.size} ä¸ªåœ°å€...`, 60);

                // æ‰¹é‡ç¬¦å·åŒ–
                const symbolMap = await batchSymbolize(Array.from(addresses));

                showProgress(true, 'æ„å»ºç«ç„°å›¾æ•°æ®...', 80);

                // æ„å»ºç«ç„°å›¾æ•°æ®
                flameData = buildFlameGraph(samples, symbolMap);

                resetZoom();
                renderFlameGraph();
                updateStats(flameData);

                showProgress(true, 'å®Œæˆ!', 100);
                setTimeout(() => showProgress(false), 500);
            } catch (e) {
                console.error('Error processing heap profile:', e);
                throw new Error('è§£æ heap profile å¤±è´¥: ' + e.message);
            }
        }

        // è§£ægperftools CPU profileäºŒè¿›åˆ¶æ ¼å¼
        function parseGperftoolsProfile(buffer) {
            const samples = [];
            const addresses = new Set();

            // åˆ›å»ºDataViewæ¥è¯»å–äºŒè¿›åˆ¶æ•°æ®
            const view = new DataView(buffer);
            const byteLength = buffer.byteLength;

            // gperftools profileæ ¼å¼ï¼š
            // Header: 24 bytes (magic, version, sampling period, padding)
            // ç„¶åæ˜¯ä¸€ç³»åˆ—é‡‡æ ·è®°å½•ï¼š
            // - count (8 bytes, uint64)
            // - pc_count (8 bytes, uint64)
            // - pcs[pc_count] (æ¯ä¸ª8 bytes, uint64)

            let offset = 24; // è·³è¿‡24å­—èŠ‚header

            function readUint64(offset) {
                // è¯»å–å°ç«¯åºçš„64ä½æ•´æ•°
                const low = view.getUint32(offset, true);
                const high = view.getUint32(offset + 4, true);
                return high * 0x100000000 + low;
            }

            while (offset + 16 <= byteLength) {
                const count = readUint64(offset);
                const pcCount = readUint64(offset + 8);

                if (pcCount === 0 || pcCount > 100) {
                    // å¼‚å¸¸æ•°æ®ï¼Œè·³è¿‡
                    offset += 16;
                    continue;
                }

                if (offset + 16 + pcCount * 8 > byteLength) {
                    // æ•°æ®ä¸å®Œæ•´
                    break;
                }

                // è¯»å–PCåˆ—è¡¨
                const stack = [];
                for (let i = 0; i < pcCount; i++) {
                    // åå‘éå†ï¼ˆä»åº•å±‚åˆ°é¡¶å±‚ï¼‰
                    const addrOffset = offset + 16 + (pcCount - 1 - i) * 8;
                    const addr = readUint64(addrOffset);
                    const addrStr = '0x' + addr.toString(16);
                    stack.push(addrStr);
                    addresses.add(addrStr);
                }

                if (stack.length > 0 && count > 0) {
                    samples.push({
                        stack: stack,
                        value: Number(count)
                    });
                }

                offset += 16 + pcCount * 8;
            }

            return { samples, addresses };
        }

        async function batchSymbolize(addresses) {
            const symbolMap = new Map();

            // åˆ†æ‰¹å¤„ç†ï¼Œæ¯æ‰¹ 100 ä¸ªåœ°å€
            const batchSize = 100;
            for (let i = 0; i < addresses.length; i += batchSize) {
                const batch = addresses.slice(i, i + batchSize);
                const addressStr = batch.join('\n');

                try {
                    const response = await fetch('/pprof/symbol', {
                        method: 'POST',
                        body: addressStr,
                        headers: {
                            'Content-Type': 'text/plain'
                        }
                    });

                    if (response.ok) {
                        const resultText = await response.text();
                        const lines = resultText.split('\n');

                        for (const line of lines) {
                            if (!line) continue;
                            const parts = line.split(' ');
                            if (parts.length >= 2) {
                                const addr = parts[0];
                                const symbol = parts.slice(1).join(' ');
                                symbolMap.set(addr, symbol);
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Symbolization failed for batch:', e);
                    // å¤±è´¥æ—¶ä½¿ç”¨åŸå§‹åœ°å€
                    for (const addr of batch) {
                        if (!symbolMap.has(addr)) {
                            symbolMap.set(addr, addr);
                        }
                    }
                }
            }

            return symbolMap;
        }

        function buildFlameGraph(samples, symbolMap) {
            const root = { name: 'root', value: 0, children: {}, hasInline: false };
            let totalSamples = 0;

            for (const sample of samples) {
                const stack = sample.stack;
                const value = sample.value;
                totalSamples += value;

                let current = root;
                for (const addr of stack) {
                    // è·å–ç¬¦å·åŒ–ç»“æœ
                    const symbol = symbolMap.get(addr.toString()) || addr.toString();

                    // æ£€æŸ¥æ˜¯å¦æœ‰å†…è”å‡½æ•°ï¼ˆä½¿ç”¨ -- åˆ†éš”ï¼‰
                    if (symbol.includes('--')) {
                        const inlineFunctions = symbol.split('--');
                        const mainFunc = inlineFunctions[0];
                        const inlinedFuncs = inlineFunctions.slice(1);

                        if (!current.children[mainFunc]) {
                            current.children[mainFunc] = {
                                name: mainFunc,
                                value: 0,
                                hasInline: true,
                                inlineChildren: {},
                                children: {}
                            };
                        }

                        let inlineParent = current.children[mainFunc];

                        for (const inlineFunc of inlinedFuncs) {
                            if (!inlineFunc) continue;

                            const inlineKey = `[inline] ${inlineFunc}`;
                            if (!inlineParent.inlineChildren[inlineKey]) {
                                inlineParent.inlineChildren[inlineKey] = {
                                    name: inlineFunc,
                                    value: 0,
                                    isInlined: true,
                                    inlineChildren: {},  // âœ… æ·»åŠ  inlineChildren å±æ€§
                                    children: {}
                                };
                            }
                            inlineParent = inlineParent.inlineChildren[inlineKey];
                        }

                        current = inlineParent;
                    } else {
                        if (!current.children[symbol]) {
                            current.children[symbol] = {
                                name: symbol,
                                value: 0,
                                hasInline: false,
                                inlineChildren: {},
                                children: {}
                            };
                        }
                        current = current.children[symbol];
                    }
                }

                current.value += value;
            }

            // è½¬æ¢ children å¯¹è±¡ä¸ºæ•°ç»„
            const convertChildren = (node) => {
                if (node.children) {
                    node.children = Object.values(node.children).map(convertChildren);

                    if (node.inlineChildren && Object.keys(node.inlineChildren).length > 0) {
                        const inlineNodes = Object.values(node.inlineChildren).map(convertChildren);
                        node.children = [...inlineNodes, ...node.children];
                    }
                }
                return node;
            };

            const tree = convertChildren(root);
            tree.total = totalSamples;

            return tree;
        }

        function renderFlameGraph() {
            if (!flameData || !flameData.children) return;

            const width = canvas.getBoundingClientRect().width;
            const height = canvas.getBoundingClientRect().height;

            ctx.clearRect(0, 0, width, height);

            const total = flameData.total || calculateTotal(flameData);
            const barHeight = 30;
            const margin = { top: 20, right: 20, bottom: 20, left: 20 };

            renderNode(flameData, margin.left, margin.top, width - margin.left - margin.right, 0, barHeight, total);
        }

        function renderNode(node, x, y, width, depth, barHeight, total) {
            if (!node || !node.children) return;

            const renderWidth = width * zoomState.scale;
            let currentX = x + zoomState.offsetX;
            const totalValue = node.value || calculateNodeTotal(node);

            if (totalValue <= 0) return;

            for (const child of node.children) {
                if (!child.value && child.children && child.children.length === 0) continue;

                const childValue = child.value || calculateNodeTotal(child);
                const childWidth = (childValue / totalValue) * renderWidth;

                if (childWidth < 1) continue;

                if (currentX + childWidth > 0 && currentX < canvas.getBoundingClientRect().width) {
                    const color = getColor(child.name, childValue, total, child.isInlined);
                    const isHighlighted = searchResults.includes(child);

                    ctx.fillStyle = isHighlighted ? '#00ff00' : color;
                    ctx.fillRect(currentX, y + depth * (barHeight + 2), childWidth, barHeight);

                    if (child.isInlined) {
                        ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                        ctx.lineWidth = 2;
                    } else {
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                        ctx.lineWidth = 1;
                    }
                    ctx.strokeRect(currentX, y + depth * (barHeight + 2), childWidth, barHeight);

                    if (childWidth > 50) {
                        ctx.fillStyle = 'white';
                        ctx.font = '11px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        let displayName = child.name;
                        const maxWidth = childWidth - 10;

                        while (ctx.measureText(displayName).width > maxWidth && displayName.length > 3) {
                            displayName = displayName.substr(0, displayName.length - 4) + '...';
                        }

                        if (displayName.length > 3) {
                            ctx.fillText(displayName, currentX + childWidth / 2, y + depth * (barHeight + 2) + barHeight / 2);
                        }
                    }
                }

                renderNode(child, currentX, y, childWidth, depth + 1, barHeight, total);
                currentX += childWidth;
            }
        }

        function getColor(name, value, total, isInlined = false) {
            if (isInlined) {
                let hash = 0;
                for (let i = 0; i < name.length; i++) {
                    hash = name.charCodeAt(i) + ((hash << 5) - hash);
                }
                const hue = 270 + (hash % 30);
                const saturation = 60 + (hash % 20);
                const lightness = 70;
                return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            } else {
                let hash = 0;
                for (let i = 0; i < name.length; i++) {
                    hash = name.charCodeAt(i) + ((hash << 5) - hash);
                }
                const intensity = value / total;
                const hue = 30 + (hash % 30);
                const saturation = 70 + (intensity * 30);
                const lightness = 60 - (intensity * 20);
                return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            }
        }

        function handleMouseMove(e) {
            if (!flameData) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const node = findNodeAtPosition(flameData, x, y, rect.width);

            if (node) {
                const total = flameData.total || calculateTotal(flameData);
                const percentage = ((node.value / total) * 100).toFixed(2);

                let tooltipContent = `
                    <div class="name">${escapeHtml(node.name)}</div>
                    <div class="value">è€—æ—¶: ${formatValue(node.value)}</div>
                    <div class="percentage">å æ¯”: ${percentage}%</div>
                `;

                if (node.isInlined) {
                    tooltipContent += `<div class="stack">âš¡ å†…è”å‡½æ•°</div>`;
                }

                tooltip.innerHTML = tooltipContent;
                tooltip.style.display = 'block';
                tooltip.style.left = (e.clientX + 15) + 'px';
                tooltip.style.top = (e.clientY + 15) + 'px';
            } else {
                tooltip.style.display = 'none';
            }
        }

        function handleClick(e) {
            if (!flameData) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const node = findNodeAtPosition(flameData, x, y, rect.width);

            if (node) {
                if (zoomState.focusedNode === node) {
                    resetZoom();
                } else {
                    zoomState.focusedNode = node;
                    updateZoomInfo(`èšç„¦: ${node.name}`);
                }
            } else {
                resetZoom();
            }
        }

        function handleWheel(e) {
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;

            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.1, Math.min(10, zoomState.scale * delta));

            zoomState.offsetX = x - (x - zoomState.offsetX) * (newScale / zoomState.scale);
            zoomState.scale = newScale;

            updateZoomInfo(`ç¼©æ”¾: ${(zoomState.scale * 100).toFixed(0)}%`);
            renderFlameGraph();
        }

        function findNodeAtPosition(node, x, y, width, depth = 0) {
            if (!node || !node.children) return null;

            const barHeight = 30;
            const margin = { top: 20, right: 20, bottom: 20, left: 20 };
            const nodeY = margin.top + depth * (barHeight + 2);

            if (y < nodeY || y > nodeY + barHeight) {
                return null;
            }

            const renderWidth = width * zoomState.scale;
            const totalValue = node.value || calculateNodeTotal(node);
            let currentX = margin.left + zoomState.offsetX;

            for (const child of node.children) {
                if (!child.value) continue;

                const childWidth = (child.value / totalValue) * renderWidth;

                if (x >= currentX && x <= currentX + childWidth) {
                    return child;
                }

                currentX += childWidth;
            }

            return null;
        }

        function searchFunction() {
            const query = document.getElementById('searchInput').value.trim();

            if (!query || !flameData) {
                searchResults = [];
                renderFlameGraph();
                return;
            }

            searchResults = [];
            searchInNode(flameData, query);

            if (searchResults.length > 0) {
                updateZoomInfo(`æ‰¾åˆ° ${searchResults.length} ä¸ªåŒ¹é…é¡¹`);
            } else {
                updateZoomInfo(`æœªæ‰¾åˆ° "${query}"`);
            }

            renderFlameGraph();
        }

        function searchInNode(node, query) {
            if (!node || !node.children) return;

            const regex = new RegExp(query, 'i');

            for (const child of node.children) {
                if (child.name && regex.test(child.name)) {
                    searchResults.push(child);
                }

                if (child.children) {
                    searchInNode(child, query);
                }
            }
        }

        function resetZoom() {
            zoomState = {
                scale: 1.0,
                offsetX: 0,
                focusedNode: null
            };

            document.getElementById('zoomInfo').style.display = 'none';
            renderFlameGraph();
        }

        function updateZoomInfo(text) {
            const zoomInfo = document.getElementById('zoomInfo');
            const zoomText = document.getElementById('zoomText');
            zoomInfo.style.display = 'block';
            zoomText.textContent = text;
        }

        function updateStats(data) {
            const total = data.total || calculateTotal(data);
            const functionCount = countFunctions(data);
            const maxValue = findMaxValue(data);

            document.getElementById('totalSamples').textContent = formatValue(total);
            document.getElementById('functionCount').textContent = functionCount;
            document.getElementById('maxValue').textContent = formatValue(maxValue);
        }

        function calculateTotal(node) {
            if (!node || !node.children) return 0;

            let total = 0;
            for (const child of node.children) {
                // é€’å½’è®¡ç®—å­èŠ‚ç‚¹çš„ totalï¼ˆåŒ…æ‹¬è‡ªèº« value å’Œæ‰€æœ‰å­å­™èŠ‚ç‚¹çš„ valueï¼‰
                total += calculateNodeTotal(child);
            }
            return total;
        }

        function calculateNodeTotal(node) {
            if (node.value && node.value > 0) return node.value;

            if (!node.children || node.children.length === 0) {
                return node.value || 0;
            }

            let sum = 0;
            for (const child of node.children) {
                sum += calculateNodeTotal(child);
            }
            return sum;
        }

        function countFunctions(node) {
            if (!node || !node.children) return 0;

            let count = 0;
            for (const child of node.children) {
                count++;
                if (child.children) {
                    count += countFunctions(child);
                }
            }
            return count;
        }

        function findMaxValue(node) {
            if (!node || !node.children) return 0;

            let max = 0;
            for (const child of node.children) {
                if (child.value > max) {
                    max = child.value;
                }
            }
            return max;
        }

        function formatValue(value) {
            if (value >= 1000000) {
                return (value / 1000000).toFixed(1) + 'M';
            } else if (value >= 1000) {
                return (value / 1000).toFixed(1) + 'K';
            }
            return value.toString();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function downloadSVG() {
            if (!flameData) {
                alert('è¯·å…ˆåŠ è½½æ•°æ®');
                return;
            }

            const width = canvas.getBoundingClientRect().width;
            const height = canvas.getBoundingClientRect().height;

            let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">
  <rect width="${width}" height="${height}" fill="#f8f9fa"/>
  <text x="20" y="30" font-family="Arial" font-size="16" fill="#333">
    ç«ç„°å›¾ - ${flameData.total} total
  </text>
</svg>`;

            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'flamegraph.svg';
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
